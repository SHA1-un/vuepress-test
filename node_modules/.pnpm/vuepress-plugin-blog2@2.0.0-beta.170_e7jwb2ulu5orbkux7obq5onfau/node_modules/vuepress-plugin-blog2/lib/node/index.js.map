{"version":3,"file":"index.js","sources":["../../src/node/utils.ts","../../src/node/category.ts","../../src/node/type.ts","../../src/node/compact.ts","../../src/node/plugin.ts"],"sourcesContent":["import { Logger } from \"vuepress-shared/node\";\n\nimport type { App, Page } from \"@vuepress/core\";\nimport type { PageMap } from \"./typings/index.js\";\n\nexport const logger = new Logger(\"vuepress-plugin-blog2\");\n\nexport const getPageMap = (\n  filter: (page: Page) => boolean,\n  app: App\n): PageMap => {\n  const pageMap: PageMap = {};\n\n  // initialize pageMap\n  Object.keys({\n    // make sure root locale exists\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    \"/\": {},\n    ...app.options.locales,\n  }).forEach((path) => {\n    pageMap[path] = [];\n  });\n\n  app.pages.filter(filter).forEach((page) => {\n    pageMap[page.pathLocale].push(page);\n  });\n\n  return pageMap;\n};\n","import { createPage } from \"@vuepress/core\";\nimport { isFunction, isString, removeLeadingSlash } from \"@vuepress/shared\";\nimport { colors } from \"@vuepress/utils\";\nimport { logger } from \"./utils.js\";\n\nimport type { App, Page } from \"@vuepress/core\";\nimport type { BlogOptions } from \"./options.js\";\nimport type { PageMap } from \"./typings/index.js\";\nimport type { CategoryMap } from \"../shared/index.js\";\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory)\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);\n  });\n\n`;\n\nexport const prepareCategory = (\n  app: App,\n  options: Partial<BlogOptions>,\n  pageMap: PageMap,\n  init = false\n): Promise<string[]> => {\n  const {\n    category = [],\n    slugify = (name: string): string =>\n      name\n        .replace(/[ _]/g, \"-\")\n        .replace(/[:?*|\\\\/<>]/g, \"\")\n        .toLowerCase(),\n  } = options;\n\n  return Promise.all(\n    category.map(\n      async (\n        {\n          key,\n          getter,\n          sorter = (): number => -1,\n          path = \"/:key/\",\n          layout = \"Layout\",\n          frontmatter = (): Record<string, string> => ({}),\n          itemPath = \"/:key/:name/\",\n          itemLayout = \"Layout\",\n          itemFrontmatter = (): Record<string, string> => ({}),\n        },\n        index\n      ) => {\n        if (!isString(key) || !key) {\n          logger.error(\n            `Invalid ${colors.magenta(\"key\")} option ${colors.cyan(\n              key\n            )} in ${colors.cyan(`category[${index}]`)}`\n          );\n\n          return null;\n        }\n\n        if (!isFunction(getter)) {\n          logger.error(\n            `Invalid ${colors.magenta(\"getter\")} option in \"${colors.cyan(\n              `category[${index}]`\n            )}\", it should be a function!`\n          );\n\n          return null;\n        }\n\n        if (app.env.isDebug)\n          logger.info(`Generating ${colors.cyan(key)} category.\\n`);\n\n        const categoryMap: CategoryMap = {};\n        const pageKeys: string[] = [];\n        const getItemPath = isFunction(itemPath)\n          ? itemPath\n          : (name: string): string =>\n              (itemPath || \"\")\n                .replace(/:key/g, slugify(key))\n                .replace(/:name/g, slugify(name));\n\n        for (const localePath in pageMap) {\n          if (path) {\n            const pagePath = `${localePath}${removeLeadingSlash(\n              path.replace(/:key/g, slugify(key))\n            )}`;\n\n            const mainPage = await createPage(app, {\n              path: pagePath,\n              frontmatter: {\n                ...frontmatter(localePath),\n                blog: {\n                  type: \"category\",\n                  key,\n                },\n                layout,\n              },\n            });\n\n            const index = app.pages.findIndex(({ path }) => path === pagePath);\n\n            if (index === -1) app.pages.push(mainPage);\n            else if (app.pages[index].key !== mainPage.key) {\n              app.pages.splice(index, 1, mainPage);\n\n              if (init)\n                logger.warn(`Overriding existed path ${colors.cyan(pagePath)}`);\n            }\n            pageKeys.push(mainPage.key);\n\n            categoryMap[localePath] = {\n              path: mainPage.path,\n              map: {},\n            };\n          } else {\n            categoryMap[localePath] = {\n              path: \"\",\n              map: {},\n            };\n          }\n\n          const { map } = categoryMap[localePath];\n          const pageMapStore: Record<string, Page[]> = {};\n\n          for (const page of pageMap[localePath]) {\n            const categories = getter(page);\n\n            for (const category of categories) {\n              if (!map[category]) {\n                const itemPath = getItemPath(category);\n\n                if (itemPath) {\n                  const pagePath = `${localePath}${removeLeadingSlash(\n                    itemPath\n                  )}`;\n\n                  const page = await createPage(app, {\n                    path: `${localePath}${removeLeadingSlash(itemPath)}`,\n                    frontmatter: {\n                      ...itemFrontmatter(category, localePath),\n                      blog: {\n                        type: \"category\",\n                        name: category,\n                        key,\n                      },\n                      layout: itemLayout,\n                    },\n                  });\n\n                  const index = app.pages.findIndex(\n                    ({ path }) => path === pagePath\n                  );\n\n                  if (index === -1) app.pages.push(page);\n                  else if (app.pages[index].key !== page.key) {\n                    app.pages.splice(index, 1, page);\n\n                    if (init)\n                      logger.warn(`Overriding existed path ${pagePath}`);\n                  }\n\n                  pageKeys.push(page.key);\n\n                  map[category] = {\n                    path: page.path,\n                    keys: [],\n                  };\n                } else {\n                  map[category] = {\n                    path: \"\",\n                    keys: [],\n                  };\n                }\n\n                pageMapStore[category] = [];\n              }\n\n              pageMapStore[category].push(page);\n            }\n          }\n\n          for (const category in pageMapStore)\n            map[category].keys = pageMapStore[category]\n              .sort(sorter)\n              .map(({ key }) => key);\n\n          if (app.env.isDebug) {\n            let infoMessage = `Route ${localePath} in ${key} category:\\n`;\n\n            for (const category in map) {\n              const { path, keys } = map[category];\n\n              infoMessage += `name: ${category}; ${\n                path ? `path: ${path}; ` : \"\"\n              }items: ${keys.length}\\n`;\n            }\n\n            logger.info(infoMessage);\n          }\n        }\n\n        return {\n          key,\n          map: categoryMap,\n          pageKeys,\n        };\n      }\n    )\n  ).then(async (result) => {\n    const finalMap: Record<string, CategoryMap> = {};\n    const keys: string[] = [];\n\n    result\n      .filter(\n        (\n          item\n        ): item is {\n          key: string;\n          map: CategoryMap;\n          pageKeys: string[];\n        } => item !== null\n      )\n      .forEach(({ key, map, pageKeys }) => {\n        finalMap[key] = map;\n        keys.push(...pageKeys);\n      });\n\n    await app.writeTemp(\n      `blog/category.js`,\n      `\\\nexport const categoryMap = ${JSON.stringify(finalMap)};\n${app.env.isDev ? HMR_CODE : \"\"}\n`\n    );\n\n    if (app.env.isDebug) logger.info(\"All categories generated.\");\n\n    return keys;\n  });\n};\n","import { createPage } from \"@vuepress/core\";\nimport { isString, removeLeadingSlash } from \"@vuepress/shared\";\nimport { colors } from \"@vuepress/utils\";\nimport { logger } from \"./utils.js\";\n\nimport type { App } from \"@vuepress/core\";\nimport type { BlogOptions } from \"./options.js\";\nimport type { PageMap } from \"./typings/index.js\";\nimport type { TypeMap } from \"../shared/index.js\";\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogType)\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);\n  });\n`;\n\nexport const prepareType = (\n  app: App,\n  options: Partial<BlogOptions>,\n  pageMap: PageMap,\n  init = false\n): Promise<string[]> => {\n  const {\n    type = [],\n    slugify = (name: string): string =>\n      name\n        .replace(/[ _]/g, \"-\")\n        .replace(/[:?*|\\\\/<>]/g, \"\")\n        .toLowerCase(),\n  } = options;\n\n  return Promise.all(\n    type.map(\n      async (\n        {\n          key,\n          sorter = (): number => -1,\n          filter = (): boolean => true,\n          path = \"/:key/\",\n          layout = \"Layout\",\n          frontmatter = (): Record<string, string> => ({}),\n        },\n        index\n      ) => {\n        if (!isString(key) || !key) {\n          logger.error(\n            `Invalid ${colors.magenta(\"key\")} option ${colors.cyan(\n              key\n            )} in ${colors.cyan(`type[${index}]`)}`\n          );\n\n          return null;\n        }\n\n        const typeMap: TypeMap = {};\n        const pageKeys: string[] = [];\n\n        if (app.env.isDebug)\n          logger.info(`Generating ${colors.cyan(key)} type.\\n`);\n\n        for (const localePath in pageMap) {\n          const keys = pageMap[localePath]\n            .filter(filter)\n            .sort(sorter)\n            .map(({ key }) => key);\n\n          if (path) {\n            const pagePath = `${localePath}${removeLeadingSlash(\n              slugify(path.replace(/:key/g, key))\n            )}`;\n\n            const page = await createPage(app, {\n              path: pagePath,\n              frontmatter: {\n                ...frontmatter(localePath),\n                blog: {\n                  type: \"type\",\n                  key,\n                },\n                layout,\n              },\n            });\n\n            const index = app.pages.findIndex(({ path }) => path === pagePath);\n\n            if (index === -1) app.pages.push(page);\n            else if (app.pages[index].key !== page.key) {\n              app.pages.splice(index, 1, page);\n\n              if (init)\n                logger.warn(`Overriding existed path ${colors.cyan(pagePath)}`);\n            }\n\n            pageKeys.push(page.key);\n\n            typeMap[localePath] = { path: page.path, keys };\n\n            if (app.env.isDebug)\n              logger.info(\n                `Route ${localePath} in ${key} type: path: ${page.path}; items: ${keys.length}\\n`\n              );\n          } else {\n            typeMap[localePath] = { path: \"\", keys };\n\n            if (app.env.isDebug)\n              logger.info(\n                `Route ${localePath} in ${key} type: items: ${keys.length}\\n`\n              );\n          }\n        }\n\n        return {\n          key,\n          map: typeMap,\n          pageKeys,\n        };\n      }\n    )\n  ).then(async (result) => {\n    const finalMap: Record<string, TypeMap> = {};\n    const keys: string[] = [];\n\n    result\n      .filter(\n        (\n          item\n        ): item is {\n          key: string;\n          map: TypeMap;\n          pageKeys: string[];\n        } => item !== null\n      )\n      .forEach(({ key, map, pageKeys }) => {\n        finalMap[key] = map;\n        keys.push(...pageKeys);\n      });\n\n    await app.writeTemp(\n      `blog/type.js`,\n      `\\\nexport const typeMap = ${JSON.stringify(finalMap)};\n${app.env.isDev ? HMR_CODE : \"\"}\n`\n    );\n\n    if (app.env.isDebug) logger.info(\"All types generated.\");\n\n    return keys;\n  });\n};\n","import { colors } from \"@vuepress/utils\";\nimport { logger } from \"./utils.js\";\nimport type { BlogOptions } from \"./options.js\";\n\n/** @deprecated */\nexport const convertOptions = (\n  options: BlogOptions & {\n    /** @deprecated */\n    customElement?: (tagName: string) => boolean;\n  }\n): void => {\n  // v2 changes\n  if (\"customElement\" in options) {\n    logger.warn(\n      `${colors.magenta(\n        \"customElement\"\n      )} is deprecated, please use ${colors.magenta(\"isCustomElement\")}.`\n    );\n\n    options[\"isCustomElement\"] = options[\"customElement\"];\n  }\n};\n","import {\n  preparePageComponent,\n  preparePageData,\n  preparePagesComponents,\n  preparePagesData,\n  preparePagesRoutes,\n} from \"@vuepress/core\";\nimport { getPageExcerpt } from \"vuepress-shared/node\";\nimport { watch } from \"chokidar\";\n\nimport { prepareCategory } from \"./category.js\";\nimport { prepareType } from \"./type.js\";\nimport { getPageMap, logger } from \"./utils.js\";\n\nimport type { PluginFunction } from \"@vuepress/core\";\nimport type { BlogOptions, PageWithExcerpt } from \"./options.js\";\nimport { convertOptions } from \"./compact.js\";\n\nexport const blogPlugin =\n  (options: BlogOptions, legacy = true): PluginFunction =>\n  (app) => {\n    // TODO: remove in V2 Stable\n    if (legacy)\n      convertOptions(options as BlogOptions & Record<string, unknown>);\n\n    const {\n      getInfo = (): Record<string, never> => ({}),\n      filter = (page): boolean =>\n        Boolean(page.filePathRelative) && !page.frontmatter[\"home\"],\n      metaScope = \"_blog\",\n      excerpt = true,\n      excerptSeparator = \"<!-- more -->\",\n      excerptLength = 300,\n      excerptFilter = filter,\n      isCustomElement = (): boolean => false,\n    } = options;\n\n    let generatePageKeys: string[] = [];\n\n    if (app.env.isDebug) logger.info(\"Options:\", options);\n\n    return {\n      name: \"vuepress-plugin-blog2\",\n\n      define: () => ({\n        BLOG_META_SCOPE: metaScope,\n      }),\n\n      extendsPage: (page): void => {\n        if (excerpt && excerptFilter(page)) {\n          (<PageWithExcerpt>page).data[\"excerpt\"] = getPageExcerpt(app, page, {\n            isCustomElement,\n            excerptSeparator,\n            excerptLength,\n          });\n        }\n\n        if (filter(page)) {\n          page.routeMeta = {\n            ...(metaScope === \"\"\n              ? getInfo(page)\n              : { [metaScope]: getInfo(page) }),\n            ...page.routeMeta,\n          };\n        }\n      },\n\n      onInitialized: (app): Promise<void> => {\n        const pageMap = getPageMap(filter, app);\n\n        return Promise.all([\n          prepareCategory(app, options, pageMap, true).then((pageKeys) => {\n            generatePageKeys.push(...pageKeys);\n          }),\n          prepareType(app, options, pageMap, true).then((pageKeys) => {\n            generatePageKeys.push(...pageKeys);\n          }),\n        ]).then(() => {\n          if (app.env.isDebug) logger.info(\"temp file generated\");\n        });\n      },\n\n      onWatched: (app, watchers): void => {\n        const hotReload =\n          \"hotReload\" in options ? options.hotReload : app.env.isDebug;\n\n        if (hotReload) {\n          const pageDataWatcher = watch(\"pages/**/*.js\", {\n            cwd: app.dir.temp(),\n            ignoreInitial: true,\n          });\n\n          const updateBlog = (): Promise<void> => {\n            const newGeneratedPageKeys: string[] = [];\n\n            const pageMap = getPageMap(filter, app);\n\n            return Promise.all([\n              prepareCategory(app, options, pageMap).then((pageKeys) => {\n                newGeneratedPageKeys.push(...pageKeys);\n              }),\n              prepareType(app, options, pageMap).then((pageKeys) => {\n                newGeneratedPageKeys.push(...pageKeys);\n              }),\n            ]).then(async () => {\n              const pagesToBeRemoved = generatePageKeys.filter(\n                (key) => !newGeneratedPageKeys.includes(key)\n              );\n              const pagesToBeAdded = newGeneratedPageKeys.filter(\n                (key) => !generatePageKeys.includes(key)\n              );\n\n              if (pagesToBeAdded.length) {\n                if (app.env.isDebug)\n                  logger.info(\n                    `New pages detected: ${pagesToBeAdded.toString()}`\n                  );\n\n                // prepare page files\n                await Promise.all(\n                  pagesToBeAdded.map(async (pageKey) => {\n                    await preparePageComponent(\n                      app,\n                      app.pages.find(({ key }) => key === pageKey)!\n                    );\n                    await preparePageData(\n                      app,\n                      app.pages.find(({ key }) => key === pageKey)!\n                    );\n                  })\n                );\n              }\n\n              // remove pages\n              if (pagesToBeRemoved.length) {\n                if (app.env.isDebug)\n                  logger.info(\n                    `Removing following pages: ${pagesToBeRemoved.toString()}`\n                  );\n\n                pagesToBeRemoved.forEach((pageKey) => {\n                  app.pages.splice(\n                    app.pages.findIndex(({ key }) => key === pageKey),\n                    1\n                  );\n                });\n              }\n\n              // prepare pages entry\n              if (pagesToBeRemoved.length || pagesToBeAdded.length) {\n                await preparePagesComponents(app);\n                await preparePagesData(app);\n                await preparePagesRoutes(app);\n              }\n\n              generatePageKeys = newGeneratedPageKeys;\n\n              if (app.env.isDebug) logger.info(\"temp file updated\");\n            });\n          };\n\n          pageDataWatcher.on(\"add\", () => {\n            void updateBlog();\n          });\n          pageDataWatcher.on(\"change\", () => {\n            void updateBlog();\n          });\n          pageDataWatcher.on(\"unlink\", () => {\n            void updateBlog();\n          });\n\n          watchers.push(pageDataWatcher);\n        }\n      },\n    };\n  };\n"],"names":["logger","Logger","getPageMap","filter","app","pageMap","path","page","HMR_CODE","prepareCategory","options","init","category","slugify","name","key","getter","sorter","layout","frontmatter","itemPath","itemLayout","itemFrontmatter","index","isString","colors","isFunction","categoryMap","pageKeys","getItemPath","localePath","pagePath","removeLeadingSlash","mainPage","createPage","map","pageMapStore","categories","infoMessage","keys","result","finalMap","item","prepareType","type","typeMap","convertOptions","blogPlugin","legacy","getInfo","metaScope","excerpt","excerptSeparator","excerptLength","excerptFilter","isCustomElement","generatePageKeys","getPageExcerpt","watchers","pageDataWatcher","watch","updateBlog","newGeneratedPageKeys","pagesToBeRemoved","pagesToBeAdded","pageKey","preparePageComponent","preparePageData","preparePagesComponents","preparePagesData","preparePagesRoutes"],"mappings":"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"}